import json
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import (
    Application,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    filters,
    ContextTypes,
)

# Загрузка данных из JSON
def load_questions(file_path: str):
    with open(file_path, "r", encoding="utf-8") as file:
        return json.load(file)["competencies"]

QUESTIONS = load_questions("questions.json")
user_data = {}

# Команда /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = str(update.effective_user.id)
    if user_id not in user_data:
        user_data[user_id] = {"current_question_index": 0, "scores": {}}
    
    keyboard = [[InlineKeyboardButton("Да", callback_data="start_assessment")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text("Готовы начать оценку компетенций?", reply_markup=reply_markup)

# Обработка нажатий на кнопки
async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    user_id = str(update.effective_user.id)
    if query.data == "start_assessment":
        await start_assessment(update, context, user_id)

# Начало оценки
async def start_assessment(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: str) -> None:
    user_data[user_id]["current_question_index"] = 0
    await ask_question(update, context, user_id)

# Задать вопрос
async def ask_question(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: str) -> None:
    current_index = user_data[user_id]["current_question_index"]
    question = QUESTIONS[0]["questions"][current_index]

    keyboard = [
        [InlineKeyboardButton(option["text"], callback_data=f"answer_{i}")]
        for i, option in enumerate(question["options"])
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    progress = f"Вопрос {current_index + 1} из {len(QUESTIONS[0]['questions'])}"
    await update.callback_query.edit_message_text(
        f"{progress}\n\n{question['question']}", reply_markup=reply_markup
    )

# Обработка ответов
async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    user_id = str(update.effective_user.id)
    answer_index = int(query.data.split("_")[1])
    current_index = user_data[user_id]["current_question_index"]

    # Сохранение ответа
    competency = QUESTIONS[0]["name"]
    if competency not in user_data[user_id]["scores"]:
        user_data[user_id]["scores"][competency] = []
    user_data[user_id]["scores"][competency].append(answer_index + 1)

    # Переход к следующему вопросу
    user_data[user_id]["current_question_index"] += 1
    if user_data[user_id]["current_question_index"] < len(QUESTIONS[0]["questions"]):
        await ask_question(update, context, user_id)
    else:
        await show_results(update, context, user_id)

# Показ результатов
async def show_results(update: Update, context: ContextTypes.DEFAULT_TYPE, user_id: str) -> None:
    scores = user_data[user_id]["scores"]
    teamwork_score = sum(scores["teamwork"]) / len(scores["teamwork"])

    await update.callback_query.edit_message_text(
        f"Ваша оценка:\n• Командная работа: {teamwork_score:.2f}/5"
    )

# Основная функция
def main() -> None:
    application = Application.builder().token("YOUR_BOT_TOKEN").build()

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(handle_callback))
    application.run_polling()

if __name__ == "__main__":
    main()
